"use strict";
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TEST_ONLY = exports.computeTextAlternative = void 0;
const context_1 = require("./context");
const options_1 = require("./options");
const rule2A_1 = require("./rule2A");
const rule2B_1 = require("./rule2B");
const rule2C_1 = require("./rule2C");
const rule2D_1 = require("./rule2D");
const rule2E_1 = require("./rule2E");
const rule2F_1 = require("./rule2F");
const rule2G_1 = require("./rule2G");
const rule2I_1 = require("./rule2I");
const ruleToImpl = {
    '2A': rule2A_1.rule2A,
    '2B': rule2B_1.rule2B,
    '2C': rule2C_1.rule2C,
    '2D': rule2D_1.rule2D,
    '2E': rule2E_1.rule2E,
    '2F': rule2F_1.rule2F,
    '2G': rule2G_1.rule2G,
    '2I': rule2I_1.rule2I,
};
/**
 * @param node - The node whose text alternative will be calculated
 * @param  context - Additional information relevant to the text alternative
 * computation for node. Optional paramater is 'getDefaultContext' by default.
 * @return - The text alternative for node
 */
function computeTextAlternative(node, options = {}, context = context_1.getDefaultContext()) {
    const result = computeRawTextAlternative(node, options_1.withDefaults(options), context);
    return {
        // # SPEC ASSUMPTION: The result of the name computation is trimmed.
        name: result.name.trim(),
        steps: result.steps,
    };
}
exports.computeTextAlternative = computeTextAlternative;
/**
 * Compute the text alternative without trimming leading and trailing
 * whitespace.
 */
function computeRawTextAlternative(node, options = options_1.withDefaults({}), context = context_1.getDefaultContext()) {
    // Try each rule sequentially on the target Node.
    for (const [rule, impl] of Object.entries(ruleToImpl)) {
        const result = impl(node, options, context, computeRawTextAlternative);
        // A rule has been applied if its implementation has
        // returned a string.
        if (result !== null) {
            // # SPEC ASSUMPTION: Even though not called out explicitly, every rule
            // should return an (untrimmed) flat string.
            const text = result.replace(/\s+/g, ' ');
            context.inherited.steps.push({
                rule: rule,
                node,
                text,
            });
            return {
                name: text,
                steps: context.inherited.steps,
            };
        }
    }
    return {
        name: '',
        steps: context.inherited.steps,
    };
}
exports.TEST_ONLY = { computeRawTextAlternative };
//# sourceMappingURL=compute_text_alternative.js.map