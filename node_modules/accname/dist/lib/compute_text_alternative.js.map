{"version":3,"file":"compute_text_alternative.js","sourceRoot":"","sources":["../../src/lib/compute_text_alternative.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;;AAEH,uCAAqD;AACrD,uCAAuD;AACvD,qCAAgC;AAChC,qCAAgC;AAChC,qCAAgC;AAChC,qCAAgC;AAChC,qCAAgC;AAChC,qCAAgC;AAChC,qCAAgC;AAChC,qCAAgC;AAwBhC,MAAM,UAAU,GAA+B;IAC7C,IAAI,EAAE,eAAM;IACZ,IAAI,EAAE,eAAM;IACZ,IAAI,EAAE,eAAM;IACZ,IAAI,EAAE,eAAM;IACZ,IAAI,EAAE,eAAM;IACZ,IAAI,EAAE,eAAM;IACZ,IAAI,EAAE,eAAM;IACZ,IAAI,EAAE,eAAM;CACb,CAAC;AAoBF;;;;;GAKG;AACH,SAAgB,sBAAsB,CAClC,IAAU,EACV,UAAmC,EAAE,EACrC,UAAmB,2BAAiB,EAAE;IAExC,MAAM,MAAM,GACR,yBAAyB,CAAC,IAAI,EAAE,sBAAY,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,CAAC;IACpE,OAAO;QACL,oEAAoE;QACpE,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE;QACxB,KAAK,EAAE,MAAM,CAAC,KAAK;KACpB,CAAC;AACJ,CAAC;AAZD,wDAYC;AAED;;;GAGG;AACH,SAAS,yBAAyB,CAC9B,IAAU,EACV,UAA0B,sBAAY,CAAC,EAAE,CAAC,EAC1C,UAAmB,2BAAiB,EAAE;IAExC,iDAAiD;IACjD,KAAK,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;QACrD,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,yBAAyB,CAAC,CAAC;QACvE,oDAAoD;QACpD,qBAAqB;QACrB,IAAI,MAAM,KAAK,IAAI,EAAE;YACnB,uEAAuE;YACvE,4CAA4C;YAC5C,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;YACzC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC;gBAC3B,IAAI,EAAE,IAAY;gBAClB,IAAI;gBACJ,IAAI;aACL,CAAC,CAAC;YAEH,OAAO;gBACL,IAAI,EAAE,IAAI;gBACV,KAAK,EAAE,OAAO,CAAC,SAAS,CAAC,KAAK;aAC/B,CAAC;SACH;KACF;IAED,OAAO;QACL,IAAI,EAAE,EAAE;QACR,KAAK,EAAE,OAAO,CAAC,SAAS,CAAC,KAAK;KAC/B,CAAC;AACJ,CAAC;AAEY,QAAA,SAAS,GAAG,EAAC,yBAAyB,EAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Context, getDefaultContext} from './context';\nimport {AccnameOptions, withDefaults} from './options';\nimport {rule2A} from './rule2A';\nimport {rule2B} from './rule2B';\nimport {rule2C} from './rule2C';\nimport {rule2D} from './rule2D';\nimport {rule2E} from './rule2E';\nimport {rule2F} from './rule2F';\nimport {rule2G} from './rule2G';\nimport {rule2I} from './rule2I';\n\n\n/**\n * A reference to the rules outlined in the accname spec.\n */\nexport type Rule = '2A'|'2B'|'2C'|'2D'|'2E'|'2F'|'2G'|'2I';\n\n/** Type signature for the computeTextAlternative function. */\nexport type ComputeTextAlternative =\n    (node: Node, options: AccnameOptions, context: Context) =>\n        ComputationDetails;\n\n/**\n * We pass the main function to compute textAlternative to avoid having build\n * time circular references between files\n */\nexport type RuleImpl = (\n    node: Node,\n    options: AccnameOptions,\n    context: Context,\n    textAlternative: ComputeTextAlternative,\n    ) => string|null;\n\nconst ruleToImpl: {[rule in Rule]: RuleImpl} = {\n  '2A': rule2A,\n  '2B': rule2B,\n  '2C': rule2C,\n  '2D': rule2D,\n  '2E': rule2E,\n  '2F': rule2F,\n  '2G': rule2G,\n  '2I': rule2I,\n};\n\n/**\n * Represents a step in the accessible name computation.\n */\nexport interface ComputationStep {\n  rule: Rule;\n  node: Node;\n  text: string;\n}\n\n/**\n * Provides details about the computation of some accessible name, such as\n * the Nodes used and rules applied during computation.\n */\nexport interface ComputationDetails {\n  name: string;\n  steps: ComputationStep[];\n}\n\n/**\n * @param node - The node whose text alternative will be calculated\n * @param  context - Additional information relevant to the text alternative\n * computation for node. Optional paramater is 'getDefaultContext' by default.\n * @return - The text alternative for node\n */\nexport function computeTextAlternative(\n    node: Node,\n    options: Partial<AccnameOptions> = {},\n    context: Context = getDefaultContext(),\n    ): ComputationDetails {\n  const result =\n      computeRawTextAlternative(node, withDefaults(options), context);\n  return {\n    // # SPEC ASSUMPTION: The result of the name computation is trimmed.\n    name: result.name.trim(),\n    steps: result.steps,\n  };\n}\n\n/**\n * Compute the text alternative without trimming leading and trailing\n * whitespace.\n */\nfunction computeRawTextAlternative(\n    node: Node,\n    options: AccnameOptions = withDefaults({}),\n    context: Context = getDefaultContext(),\n    ): ComputationDetails {\n  // Try each rule sequentially on the target Node.\n  for (const [rule, impl] of Object.entries(ruleToImpl)) {\n    const result = impl(node, options, context, computeRawTextAlternative);\n    // A rule has been applied if its implementation has\n    // returned a string.\n    if (result !== null) {\n      // # SPEC ASSUMPTION: Even though not called out explicitly, every rule\n      // should return an (untrimmed) flat string.\n      const text = result.replace(/\\s+/g, ' ');\n      context.inherited.steps.push({\n        rule: rule as Rule,\n        node,\n        text,\n      });\n\n      return {\n        name: text,\n        steps: context.inherited.steps,\n      };\n    }\n  }\n\n  return {\n    name: '',\n    steps: context.inherited.steps,\n  };\n}\n\nexport const TEST_ONLY = {computeRawTextAlternative};\n"]}