{"version":3,"file":"rule2B.js","sourceRoot":"","sources":["../../src/lib/rule2B.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;;AAKH,iCAAqC;AAErC;;;;;;GAMG;AACH,SAAgB,gCAAgC,CAAC,IAAiB;;IAEhE,MAAM,MAAM,eAAG,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,0CAAE,KAAK,CAAC,GAAG,oCAAK,EAAE,CAAC;IAEtE,MAAM,UAAU,GAAkB,EAAE,CAAC;IACrC,KAAK,MAAM,EAAE,IAAI,MAAM,EAAE;QACvB,MAAM,IAAI,GAAG,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;QACzC,IAAI,IAAI,EAAE;YACR,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACvB;KACF;IACD,OAAO,UAAU,CAAC;AACpB,CAAC;AAZD,4EAYC;AAED;;;;;;;;GAQG;AACH,SAAgB,MAAM,CAClB,IAAU,EACV,OAAuB,EACvB,OAAgB,EAChB,sBAA8C;IAEhD,IAAI,CAAC,oBAAa,CAAC,IAAI,CAAC,EAAE;QACxB,OAAO,IAAI,CAAC;KACb;IAED,qEAAqE;IACrE,aAAa;IACb,IAAI,OAAO,CAAC,oBAAoB,EAAE;QAChC,OAAO,IAAI,CAAC;KACb;IAED,MAAM,UAAU,GAAG,gCAAgC,CAAC,IAAI,CAAC,CAAC;IAC1D,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;QAC3B,OAAO,IAAI,CAAC;KACb;IAED,OAAO,UAAU;SACZ,GAAG,CAAC,SAAS,CAAC,EAAE;QACf,OAAO,CAAC,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC;QACpC,OAAO,sBAAsB,CAAC,SAAS,EAAE,OAAO,EAAE;YACzC,oBAAoB,EAAE,IAAI;YAC1B,SAAS,EAAE,OAAO,CAAC,SAAS;SAC7B,CAAC;aACJ,IAAI,CAAC;IACZ,CAAC,CAAC;SACD,IAAI,CAAC,GAAG,CAAC;SACT,IAAI,EAAE,CAAC;AACd,CAAC;AAhCD,wBAgCC","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ComputeTextAlternative} from './compute_text_alternative';\nimport {Context} from './context';\nimport {AccnameOptions} from './options';\nimport {isHTMLElement} from './util';\n\n/**\n * Get any HTMLElement referenced in the aria-labelledby attribute\n * of 'elem' that exist in the document (i.e is 'valid')\n * @param elem - element whose aria-labelledby attribute is considered\n * @return - An array of any HTMLElement in the document that is referenced\n * by elem's aria-labelledby\n */\nexport function resolveValidAriaLabelledbyIdrefs(elem: HTMLElement):\n    HTMLElement[] {\n  const idrefs = elem.getAttribute('aria-labelledby')?.split(' ') ?? [];\n\n  const validElems: HTMLElement[] = [];\n  for (const id of idrefs) {\n    const elem = document.getElementById(id);\n    if (elem) {\n      validElems.push(elem);\n    }\n  }\n  return validElems;\n}\n\n/**\n * Implementation of rule 2B\n * @param node - node whose text alternative is being computed\n * @param context - Additional information relevant to the text alternative\n * computation for node\n * @return - The text alternative string is returned if condition is true,\n * null is returned otherwise, indicating that the condition of this rule was\n * not satisfied.\n */\nexport function rule2B(\n    node: Node,\n    options: AccnameOptions,\n    context: Context,\n    computeTextAlternative: ComputeTextAlternative,\n    ): string|null {\n  if (!isHTMLElement(node)) {\n    return null;\n  }\n\n  // #SPEC_ASSUMPTION (B.1) : definition of 'part of an aria-labelledby\n  // traversal'\n  if (context.directLabelReference) {\n    return null;\n  }\n\n  const labelElems = resolveValidAriaLabelledbyIdrefs(node);\n  if (labelElems.length === 0) {\n    return null;\n  }\n\n  return labelElems\n      .map(labelElem => {\n        context.inherited.partOfName = true;\n        return computeTextAlternative(labelElem, options, {\n                 directLabelReference: true,\n                 inherited: context.inherited,\n               })\n            .name;\n      })\n      .join(' ')\n      .trim();\n}\n"]}