"use strict";
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.rule2C = void 0;
const rule2E_1 = require("./rule2E");
const util_1 = require("./util");
/**
 * Implementation for rule 2C
 * @param node - node whose text alternative is being computed
 * @param context - information relevant to the computation of node's text
 *     alternative
 * @return text alternative for 'node' if rule 2C accepts 'node', null
 *     otherwise.
 */
function rule2C(node, options, context, computeTextAlternative) {
    var _a;
    if (!util_1.isElement(node)) {
        return null;
    }
    const ariaLabel = (_a = node.getAttribute('aria-label')) !== null && _a !== void 0 ? _a : '';
    if (ariaLabel.trim() === '') {
        return null;
    }
    // #SPEC_ASSUMPTION (C.1) : 'part of name' implies 'traversal
    // due to recursion'.
    if (context.inherited.partOfName) {
        // 'rule2EResult !== null' indicates that 'node' is an embedded
        // control as defined in step 2E.
        const rule2EResult = rule2E_1.rule2E(node, options, { inherited: context.inherited }, computeTextAlternative);
        if (rule2EResult !== null) {
            return rule2EResult;
        }
    }
    return ariaLabel;
}
exports.rule2C = rule2C;
//# sourceMappingURL=rule2C.js.map