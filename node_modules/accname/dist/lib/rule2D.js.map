{"version":3,"file":"rule2D.js","sourceRoot":"","sources":["../../src/lib/rule2D.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ComputeTextAlternative} from './compute_text_alternative';\nimport {Context} from './context';\nimport {AccnameOptions} from './options';\nimport {hasTagName, isHTMLElement, isSVGElement} from './util';\n\n/**\n * Process elem's text alternative if elem is an <input>, assuming\n * that no <label> element references elem.\n * @param elem - element whose text alternative is being processed\n * @return - text alternative of elem if elem is an <input>\n */\nexport function getUnlabelledInputText(elem: HTMLInputElement): string|null {\n  // Implementation reflects rules defined in sections 5.1 - 5.3 of html-aam\n  // spec:\n  // https://www.w3.org/TR/html-aam-1.0/#accessible-name-and-description-computation\n\n  const inputType = elem.getAttribute('type') ?? '';\n  if ((inputType === 'button' || inputType === 'submit' ||\n       inputType === 'reset') &&\n      elem.hasAttribute('value')) {\n    return elem.value;\n  }\n\n  if (inputType === 'submit' || inputType === 'reset') {\n    // This should be a localised string, but for now we are\n    // just supporting English.\n    return inputType;\n  }\n\n  if (inputType === 'image' && elem.hasAttribute('alt')) {\n    return elem.getAttribute('alt');\n  }\n\n  if (inputType === 'image' && !elem.hasAttribute('title')) {\n    // This should be a localised string, but for now we are\n    // just supporting English.\n    return 'Submit Query';\n  }\n\n  // Title attribute handled by 2I.\n\n  return null;\n}\n\n// Only certain element types are labellable\n// See: https://html.spec.whatwg.org/multipage/forms.html#category-label\nexport const LABELLABLE_ELEMENT_TYPES = [\n  'BUTTON',\n  'INPUT',\n  'METER',\n  'OUTPUT',\n  'PROGRESS',\n  'SELECT',\n  'TEXTAREA',\n];\n\n/** Checks if `control` is the element that is labelled by `label` */\nfunction isLabelledControl(\n    label: HTMLLabelElement, control: HTMLElement): boolean {\n  if (label.control !== undefined) {\n    return label.control === control;\n  } else {\n    // For ie & edge\n    if (label.htmlFor !== '' && label.htmlFor === control.id) {\n      return true;\n    } else if (label.htmlFor === '' && label.contains(control)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\nfunction hasPresentationRole(el: HTMLElement): boolean {\n  const explicitRole = el.getAttribute('role');\n  if (explicitRole === 'presentation' || explicitRole === 'none') {\n    return true;\n  }\n\n  // Implicit presentation role.\n  if (explicitRole === null && hasTagName(el, 'img') &&\n      el.getAttribute('alt') === '') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Gets the text alternative as defined by one or more native <label>s.\n * @param elem - element whose text alternative is being calculated\n * @param context - information relevant to the computation of elem's text\n *     alternative\n * @return - the text alternative for elem if elem is legally labelled by a\n *     native\n * <label>, null otherwise.\n */\nfunction getTextIfLabelled(\n    elem: HTMLElement,\n    options: AccnameOptions,\n    context: Context,\n    computeTextAlternative: ComputeTextAlternative,\n    ): string|null {\n  // Using querySelectorAll to get <label>s in DOM order.\n  const allLabelElems = document.querySelectorAll('label');\n  const labelElems =\n      Array.from(allLabelElems).filter(label => isLabelledControl(label, elem));\n\n  const textAlternative =\n      labelElems\n          .map(labelElem => computeTextAlternative(labelElem, options, {\n                              directLabelReference: true,\n                              inherited: context.inherited,\n                            }).name)\n          .filter(text => text !== '')\n          .join(' ');\n\n  return textAlternative || null;\n}\n\n/**\n * Implementation for rule 2D\n * @param node - the node whose text alternative is being computed\n * @param context - information relevant to the text alternative computation\n * for node\n * @return - text alternative for node if the conditions for applying\n * rule 2D are satisfied, null otherwise.\n */\nexport function rule2D(\n    node: Node,\n    options: AccnameOptions,\n    context: Context,\n    computeTextAlternative: ComputeTextAlternative,\n    ): string|null {\n  // <title>s define text alternatives for <svg>s\n  // See: https://www.w3.org/TR/svg-aam-1.0/#mapping_additional_nd\n  if (isSVGElement(node)) {\n    for (const child of node.childNodes) {\n      if (isSVGElement(child) && hasTagName(child, 'title')) {\n        return child.textContent;\n      }\n    }\n  }\n\n  if (!isHTMLElement(node)) {\n    return null;\n  }\n\n  if (hasPresentationRole(node)) {\n    return null;\n  }\n\n  // #SPEC_ASSUMPTION (D.1) : html-aam (https://www.w3.org/TR/html-aam-1.0/)\n  // specifies all native attributes and elements that define a text\n  // alternative.\n  if (LABELLABLE_ELEMENT_TYPES.includes(node.tagName)) {\n    const labelText =\n        getTextIfLabelled(node, options, context, computeTextAlternative);\n    if (labelText) {\n      return labelText;\n    }\n  }\n\n  // If input is not <label>led, use native attribute /\n  // element information to compute a text alternative\n  if (hasTagName(node, 'input')) {\n    const inputTextAlternative = getUnlabelledInputText(node);\n    if (inputTextAlternative) {\n      return inputTextAlternative;\n    }\n  }\n\n  // <caption>s define text alternatives for <table>s\n  if (hasTagName(node, 'table')) {\n    const captionElem = node.querySelector('caption');\n    if (captionElem) {\n      context.inherited.partOfName = true;\n      return computeTextAlternative(captionElem, options, {\n               inherited: context.inherited,\n             })\n          .name;\n    }\n  }\n\n  // <figcaption>s define text alternatives for <figure>s\n  if (hasTagName(node, 'figure')) {\n    const figcaptionElem = node.querySelector('figcaption');\n    if (figcaptionElem) {\n      context.inherited.partOfName = true;\n      return computeTextAlternative(figcaptionElem, options, {\n               inherited: context.inherited,\n             })\n          .name;\n    }\n  }\n\n  // <legend>s define text alternatives for <fieldset>s\n  if (hasTagName(node, 'fieldset')) {\n    const legendElem = node.querySelector('legend');\n    if (legendElem) {\n      context.inherited.partOfName = true;\n      return computeTextAlternative(legendElem, options, {\n               inherited: context.inherited,\n             })\n          .name;\n    }\n  }\n\n  // alt attributes define text alternatives for\n  // <img>s and <area>s\n  const altAttribute = node.getAttribute('alt');\n  if (altAttribute && (hasTagName(node, 'img') || hasTagName(node, 'area'))) {\n    return altAttribute;\n  }\n\n  return null;\n}\n"]}