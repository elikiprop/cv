{"version":3,"file":"rule2E.js","sourceRoot":"","sources":["../../src/lib/rule2E.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ComputeTextAlternative} from './compute_text_alternative';\nimport {Context} from './context';\nimport {AccnameOptions} from './options';\nimport {hasTagName, isHTMLElement} from './util';\n\n\n// Input types that imply role 'textbox' if list attribute is not present,\n// and imply role 'combobox' if list attribute is present.\nexport const TEXT_INPUT_TYPES = ['email', 'tel', 'text', 'url', 'search'];\n\n/**\n * Determines whether a given node has role 'textbox' and,\n * if so, gets the value of that textbox.\n * @param node - element whose role is being calculated\n * @return - textbox value if node is a textbox, null otherwise\n * (null indicates that node is not a textbox).\n */\nexport function getValueIfTextbox(node: HTMLElement): string|null {\n  // #SPEC_ASSUMPTION (E.3) : Explicit role='textbox' are handled by rule2F.\n\n  // Handles the case where node role is explictly overwritten\n  const nodeRole = node.getAttribute('role');\n  if (nodeRole && nodeRole !== 'textbox') {\n    return null;\n  }\n\n  // type <textarea> implies role='textbox'\n  if (hasTagName(node, 'textarea')) {\n    return node.value;\n  }\n\n  // <input> with certain type values & no list attribute implies role='textbox'\n  if (hasTagName(node, 'input') && TEXT_INPUT_TYPES.includes(node.type) &&\n      !node.hasAttribute('list')) {\n    return node.value;\n  }\n\n  return null;\n}\n\n// Input types that imply role 'range'\nconst RANGE_INPUT_TYPES = ['number', 'range'];\n\n// Roles for whom 'range' is a superclass.\n// Each of these roles explicitly defines the 'range' role.\nconst RANGE_ROLES = ['spinbutton', 'slider', 'progressbar', 'scrollbar'];\n\n/**\n * Determines whether a given node has role 'range' and,\n * if so, gets the text alternative for that node.\n * @param node - node whose role is being calculated\n * @return - text alternative for node if node is a 'range',\n * null otherwise (indicating that node is not a range).\n */\nexport function getValueIfRange(node: HTMLElement): string|null {\n  const nodeRoleAttribute = node.getAttribute('role') ?? '';\n  const isExplicitRange = RANGE_ROLES.includes(nodeRoleAttribute);\n\n  // Handles the case where node role is explictly overwritten\n  if (nodeRoleAttribute && !isExplicitRange) {\n    return null;\n  }\n\n  const isImplicitRange =\n      (hasTagName(node, 'input') && RANGE_INPUT_TYPES.includes(node.type)) ||\n      hasTagName(node, 'progress');\n\n  if (isExplicitRange || isImplicitRange) {\n    if (node.hasAttribute('aria-valuetext')) {\n      return node.getAttribute('aria-valuetext');\n    }\n    if (node.hasAttribute('aria-valuenow')) {\n      return node.getAttribute('aria-valuenow');\n    }\n    if (hasTagName(node, 'input')) {\n      return node.value;\n    }\n    if (hasTagName(node, 'progress')) {\n      return node.value.toString();\n    }\n  }\n\n  return null;\n}\n\n/**\n * Determines whether a given node has role 'combobox'\n * or 'listbox' and, if so, gets the text alternative for the\n * option(s) selected by that combobox / listbox.\n * @param node - node whose role is being calculated\n * @param context - information relevant to the calculation of that role\n * @return - text alternative for selected option(s) if node is a\n * combobox or listbox, null otherwise.\n * (null indicates that node is neither combobox nor listbox).\n */\nfunction getValueIfComboboxOrListbox(\n    node: HTMLElement,\n    options: AccnameOptions,\n    context: Context,\n    computeTextAlternative: ComputeTextAlternative,\n    ): string|null {\n  // Handles the case where node role is explictly overwritten\n  const nodeRole = node.getAttribute('role');\n  if (nodeRole && nodeRole !== 'listbox' && nodeRole !== 'combobox') {\n    return null;\n  }\n\n  // Combobox role implied by input type and presence of list attribute,\n  // chosen option is the input value.\n  if (hasTagName(node, 'input') && TEXT_INPUT_TYPES.includes(node.type) &&\n      (node.hasAttribute('list') || nodeRole === 'combobox')) {\n    return node.value;\n  }\n\n  // Text alternative for elems of role 'listbox' and 'combobox'\n  // consists of the text alternatives for their selected options.\n  let selectedOptions: HTMLElement[] = [];\n  // Listbox may be defined explicitly using 'role',\n  // and using 'aria-selected' attribute to mark selected options.\n  if (nodeRole && nodeRole === 'listbox') {\n    selectedOptions = Array.from(\n        node.querySelectorAll('[role=\"option\"][aria-selected=\"true\"]'));\n  }\n  // A <select> element is always implicitly either a listbox or a combobox\n  else if (hasTagName(node, 'select')) {\n    selectedOptions = Array.from(node.selectedOptions);\n  }\n\n  // If the current node has any selected options (either by aria-selected\n  // or semantic <option selected>) they will be stored in selectedOptions.\n  if (selectedOptions.length > 0) {\n    // #SPEC_ASSUMPTION (E.2) : consider multiple selected options' text\n    // alternatives, joining them with a space as in 2B.ii.c\n    return selectedOptions\n        .map(optionElem => computeTextAlternative(optionElem, options, {\n                             inherited: context.inherited,\n                           }).name)\n        .filter(alternativeText => alternativeText !== '')\n        .join(' ');\n  }\n\n  return null;\n}\n\n/**\n * Implementation for rule 2E.\n * @param node - node whose text alternative is being calculated\n * @param context - additional information relevant to the computation of a text\n * alternative for node.\n * @return text alternative for 'node' if rule 2E accepts 'node', null\n *     otherwise.\n */\nexport function rule2E(\n    node: Node,\n    options: AccnameOptions,\n    context: Context,\n    computeTextAlternative: ComputeTextAlternative,\n    ): string|null {\n  if (!isHTMLElement(node)) {\n    return null;\n  }\n\n  // #SPEC_ASSUMPTION (E.1) : that 'embedded within the label\n  // for another widget' is equivalent to 'part of a name computation'\n  if (!context.inherited.partOfName) {\n    return null;\n  }\n\n  const textboxValue = getValueIfTextbox(node);\n  if (textboxValue) {\n    return textboxValue;\n  }\n\n  // #SPEC_ASSUMPTION (E.4) : menu button is handled by 2F\n\n  const comboboxOrListboxValue = getValueIfComboboxOrListbox(\n      node, options, context, computeTextAlternative);\n  if (comboboxOrListboxValue) {\n    return comboboxOrListboxValue;\n  }\n\n  const rangeValue = getValueIfRange(node);\n  if (rangeValue) {\n    return rangeValue;\n  }\n\n  return null;\n}\n"]}