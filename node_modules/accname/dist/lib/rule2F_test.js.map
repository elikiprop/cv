{"version":3,"file":"rule2F_test.js","sourceRoot":"","sources":["../../src/lib/rule2F_test.ts"],"names":[],"mappings":"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","sourcesContent":["import {html, render} from 'lit';\n\nimport {createRuleRunner} from '../testing/utils';\n\nimport {getDefaultContext} from './context';\nimport {withDefaults} from './options';\nimport {rule2F as rule2FImpl, TEST_ONLY} from './rule2F';\n\nconst rule2F = createRuleRunner(rule2FImpl);\n\ndescribe('The function for rule 2F', () => {\n  let container: HTMLElement;\n  beforeEach(() => {\n    container = document.createElement('div');\n    document.body.appendChild(container);\n  });\n\n  afterEach(() => {\n    document.body.removeChild(container);\n  });\n\n  it('returns text content of role=\"button\" nodes', () => {\n    render(\n        html`\n        <div id=\"foo\" role=\"button\">\n          Hello world\n        </div>\n      `,\n        container);\n    const elem = document.getElementById('foo');\n    expect(rule2F(elem!)).toBe('Hello world');\n  });\n\n  it('returns text content of subtree if node is a label element', () => {\n    render(\n        html`\n        <label id=\"foo\">\n          <div>\n            Hello\n            <div>\n              <div>\n                world\n              </div>\n            </div>\n          </div>\n          <div>!</div>\n        </label>\n      `,\n        container);\n    const elem = document.getElementById('foo');\n    const context = getDefaultContext();\n    context.directLabelReference = true;\n    expect(rule2F(elem!, context)).toBe('Hello world !');\n  });\n\n  it('returns a string concatenated with CSS generated text content for inline elements if includePseudoElements is true',\n     () => {\n       render(\n           html`\n        <style>\n          #foo:before {\n            content: 'Hello';\n          }\n          #foo:after {\n            content: '!';\n          }\n        </style>\n        <div id=\"foo\">world</div>\n      `,\n           container);\n       const elem = document.getElementById('foo');\n       const context = getDefaultContext();\n       const options = withDefaults({includePseudoElements: true});\n       context.directLabelReference = true;\n       expect(rule2F(elem!, context, options)).toBe('Helloworld!');\n     });\n\n  it('returns a string concatenated with CSS generated text content for block elements if includePseudoElements is true',\n     () => {\n       render(\n           html`\n        <style>\n          #foo:before {\n            content: 'Hello';\n            display: block;\n          }\n          #foo:after {\n            content: '!';\n          }\n        </style>\n        <div id=\"foo\">world</div>\n      `,\n           container);\n       const elem = document.getElementById('foo');\n       const context = getDefaultContext();\n       const options = withDefaults({includePseudoElements: true});\n       context.directLabelReference = true;\n       expect(rule2F(elem!, context, options)).toBe('Hello world!');\n     });\n\n  it('doesn\\'t include non-textual CSS content', () => {\n    render(\n        html`\n        <style>\n          #foo:before {\n            content: url('a/url/to/some/image');\n          }\n        </style>\n        <div id=\"foo\">\n          Hello world\n        </div>\n      `,\n        container);\n    const elem = document.getElementById('foo');\n    const context = getDefaultContext();\n    const options = withDefaults({includePseudoElements: true});\n    context.directLabelReference = true;\n    expect(rule2F(elem!, context, options)).toBe('Hello world');\n  });\n\n  it('ignores CSS generated text content by default', () => {\n    render(\n        html`\n        <style>\n          #foo:before {\n            content: 'Hello';\n          }\n          #foo:after {\n            content: '!';\n          }\n        </style>\n        <div id=\"foo\">world</div>\n      `,\n        container);\n    const elem = document.getElementById('foo');\n    const context = getDefaultContext();\n    context.directLabelReference = true;\n    expect(rule2F(elem!, context)).toBe('world');\n  });\n\n  it('doesn\\'t visit the same node twice during a recursive traversal', () => {\n    render(\n        html`\n        <div id=\"foo\">\n          Hello\n          <div aria-labelledby=\"bar\"></div>\n        </div>\n        <div id=\"bar\">\n          world\n          <div aria-labelledby=\"foo\"></div>\n        </div>\n      `,\n        container);\n    const elem = document.getElementById('foo');\n    const context = getDefaultContext();\n    context.directLabelReference = true;\n    expect(rule2F(elem!, context)).toBe('Hello world');\n  });\n\n  it('returns text alternative for entire subtree of node referenced by aria-labelledby',\n     () => {\n       render(\n           html`\n        <div id=\"foo\" aria-labelledby=\"bar\">\n          <div id=\"bar\">\n            Hello\n            <div>\n              world\n              <div>\n                !\n              </div>\n            </div>\n          </div>\n        </div>\n      `,\n           container);\n       const elem = document.getElementById('foo');\n       const context = getDefaultContext();\n       context.directLabelReference = true;\n       expect(rule2F(elem!, context)).toBe('Hello world !');\n     });\n\n  it('returns null if the conditions for applying rule2F are not satisfied',\n     () => {\n       render(html` <div id=\"foo\"></div> `, container);\n       const elem = document.getElementById('foo');\n       expect(rule2F(elem!)).toBe(null);\n     });\n});\n\n\ndescribe('name from content tables', () => {\n  const tables = new Map([\n    ['always', TEST_ONLY.ALWAYS_NAME_FROM_CONTENT],\n    ['sometimes', TEST_ONLY.SOMETIMES_NAME_FROM_CONTENT],\n    ['never', TEST_ONLY.NEVER_NAME_FROM_CONTENT],\n  ]);\n\n  for (const [name1, table1] of tables.entries()) {\n    describe(`the set of roles that take name from content \"${name1}\"`, () => {\n      for (const [name2, table2] of tables.entries()) {\n        if (name1 !== name2) {\n          it(`should not contain any of the roles that take name from content \"${\n                 name2}\"`,\n             () => {\n               for (const role of table2.roles) {\n                 expect(table1.roles).not.toContain(role);\n               }\n             });\n        }\n      }\n    });\n  }\n});\n"]}