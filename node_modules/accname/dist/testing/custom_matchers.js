"use strict";
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.customMatchers = void 0;
const compute_text_alternative_1 = require("../lib/compute_text_alternative");
/** Custom helpers for assertions. */
exports.customMatchers = {
    toHaveTextAlernative(util) {
        return {
            compare(nodeOrHtml, expected) {
                let textAlternative;
                if (typeof nodeOrHtml === 'string') {
                    const div = document.createElement('div');
                    div.innerHTML = nodeOrHtml;
                    document.body.appendChild(div);
                    textAlternative = compute_text_alternative_1.computeTextAlternative(div.querySelector('#test'));
                    document.body.removeChild(div);
                }
                else {
                    textAlternative = compute_text_alternative_1.computeTextAlternative(nodeOrHtml);
                }
                return {
                    pass: util.equals(textAlternative.name, expected),
                    message: `Text alternative check failed:

Expected name: "${expected}"
Actual name: "${textAlternative.name}"

Details:
${textAlternative.steps.map(printStep).join('\n')}
`
                };
            },
        };
    },
};
function printStep(step) {
    return ` - Got '${step.text}' by applying rule ${step.rule} on ${serialize(step.node)}`;
}
function serialize(node) {
    switch (node.nodeType) {
        case Node.TEXT_NODE:
            return `Text("${node.data.replace(/\n/g, '\\n')}")`;
        case Node.ELEMENT_NODE:
            return node.outerHTML;
        default:
            return `{unknown node: ${node}}`;
    }
}
//# sourceMappingURL=custom_matchers.js.map